---
title: "Basic model of evolutionary rescue in discrete time"
author: "Iona & Pascal"
date: "2025-10-15"


output:
  html_document:
    df_print: paged
---

## Simulating evolutionary rescue in discrete time

In this notebook, we are implementing simulations of evolutionary rescue by introducing an other species. The model is as follows: a diploid homozygot population (aa) is dying of, due to a recessive fitness disadvantage on a. At time x a few homozygot individuals (AA) are introduced to save the population by hybridization.

**Idea:** Inbreed depression in population with recessive disease (aa) that leads to lower fitness and is therefore declining in population size. Goal is to rescue population with hybrids. How many healthy individuals are needed to rescue the population. only healthy (AA) are added,

**Assumptions:**

\- starting population is homozygot for the disease (aa)

\- healthy added individuals are homozygot without the disease (AA)

\- second generation can mate with sick individual or hybrid

**Question:** How many individuals have to be introduced at time x to rescue an allele of a homozygot population with low fitness?

=======

First we define the variables and parameters.

*Parameters we need:*

-   `N_aa` initial population size of the genotype aa

-   `N_aA` initial population size of the genotype aA

-   `N_AA` initial population size of the genotype AA

-   `r_aa` fitness of genotype aa

-   `s_aA` fitness of genotype aA

-   `s_AA` fitness of genotype AA

-   `max_pop_size` pop size, at which simulation stops

*Variables we need:*

-   `offsp_aa` number of offspring of the given genotype
-   `N_aa_new` number of the given genotype after one generation
-   `total_gametes` number of all alleles combined
-   `freq_a` number of the given allele in the population
-   `predicted_freq_aa` number of the given genotype in the next generation
-   `t_max` number of generation till extinction/ rescue

*Functions we need:*

-   `simulate_gen` models one generation step
-   `simulate_pop` models multiple generation steps

## Simulate one generation of population size change

First we need a function that simulates one generation step in the population. Using a poisson distribution, amount of parent generation and accounting for the different fitness benefits of each genotype, the number of offspring per genotype is determind.

In a next step, we count the frequency of allel a and A in the new population. With the help of the Hardy-Weinberg equilibrium, we then predict the new allel frequency in the population. To account for extinction we created an if loop, which would skips the steps starting from the prediction of the allele frequency, and would return to the function a vector with zeros.

```{r}

#defining starting pop size of the genotypes
N_aa <- 100
N_aA <- 0
N_AA <- 10

#defining fitness reduction & benefit of the genotypes
r_aa <- 0.2         # fitness reduction of aa allel comb. equal to decay_rate
s_aA <- 1.10        # fitness benefit of allel A, equal to sel_coeff
s_AA <- 1.10        # fitness benefit of allel A, equal to sel_coeff



# --- Simulation of one generation with three genotypes ---
simulate_gen <- function(N_aa, N_aA, N_AA, r_aa, s_aA, s_AA) {

  # Reproduction with fitness malus/benefit
  offsp_aa <- rpois(1, N_aa * (1-r_aa))
  offsp_aA <- rpois(1, N_aA * s_aA)
  offsp_AA <- rpois(1, N_AA * s_AA)  
  
  # Total numbeer of gamets proportional to the frequency of alleles A and a
  total_gametes <- 2 * (offsp_aa + offsp_aA + offsp_AA)
  freq_A <- (2 * offsp_AA + offsp_aA) 
  freq_a <- total_gametes - freq_A
  
  
  
  # if loop to account for extinction
  if (total_gametes > 0) {

  # Change of allele frequencies (A -> a, a -> A); p = (freq_A / total_gametes), q = (freq_a / total_gametes) 
  # hardy equilibrium 1 = p^2 +2pq +q^2
  predicted_freq_aa <- (freq_a/total_gametes)^2
  predicted_freq_aA <- 2*(freq_A / total_gametes)*(freq_a / total_gametes)
  predicted_freq_AA <- (freq_A/total_gametes)^2
  
   # Random draw of new genotypes under hardy-weinberg conditions
  N_total <- offsp_aa + offsp_aA + offsp_AA
  genotypes <- rmultinom(1, N_total, prob = c(predicted_freq_aa, predicted_freq_aA, predicted_freq_AA))
  
  N_aa_new <- genotypes[1]
  N_aA_new <- genotypes[2]
  N_AA_new <- genotypes[3]

  return(c(N_aa_new, N_aA_new, N_AA_new))
  }
  
  # in case of extinction
  else
  return(c(0,0,0))
  
  
}

print(simulate_gen(N_aa, N_aA, N_AA, r_aa, s_aA, s_AA))
```

## Simulate a population trajectory

Now we create a function that generates a population over time, using the function simulate_gen multiple times. We need two vectors to collect the data, one to save the result and the other to calculate the new pop size. With a for loop we then count the generations we want to create and with each count we run the function simulate_gen. The new pop sizes get added to the vector in each round and are then used for the new round. An if argument makes sure that the loop gets stoped if the population gets extinct or the pop size is x-times bigger than the original pop size.

We use this function and then create a plot, that shows the number of the different genotypes over time plus the total pop size.

```{r}

# parameter to stop simulation pop if this pop size is reached
max_pop_size <- 100


# creat function to generate a population, using the function to generate a generation
simulate_pop <- function(N_aa, N_aA, N_AA, r_aa, s_aA, s_AA, t_max) {
  
  # Create the vector in which to save the results
  pop_vector <- c(N_aa, N_aA, N_AA)
  # initiate the variables
  pop_new <- c(N_aa, N_aA, N_AA)
  
  # run the simulation until generation t_max
  for (i in 1:(t_max+1)) {
   
    # break for loop if pop went extinct or x-times pop size
    if (pop_new[1]+pop_new[2]+pop_new[3]>=max_pop_size*(N_aa+N_aA+N_AA) | pop_new[1]+pop_new[2]+pop_new[3]==0) break
   
    # redefine the current population one generation later
    pop_new <- simulate_gen(pop_new[1],pop_new[2],pop_new[3], r_aa, s_aA, s_AA)
    
    
    # add the new population sizes to the output vector
    pop_vector <- rbind(pop_vector,pop_new)
  }
  
  # define the row and column names of the output vector 
  rownames(pop_vector) <- (0:t_max+1)[1:length(pop_vector[,1])]  
  colnames(pop_vector) <- c("aa","aA","AA")
  
  # return the result
  return(pop_vector)	
}




###### Test the function and plot the result

# set t_max to a value to be used througout
t_max <- 1000

# create your simulation data
output <- simulate_pop(N_aa, N_aA, N_AA, r_aa, s_aA, s_AA, t_max)

# show the last few lines of the data table
print(tail(output))




###### plot the output 

# determine x axis range 
x_range <- 0:(length(output[,1])-1)

# plots the total population size
plot(x_range,output[,1]+output[,2]+output[,3],type='l',ylim=c(0,max(output[,1]+output[,2]+output[,3])),xlab = "Generation",ylab = "Population size")

# add number of aa genotype
lines(x_range,output[,1], col="blue") 
# add number of aA genotype
lines(x_range,output[,2], col="red")
# add number of AA genotype
lines(x_range,output[,3], col="green")

```

## Simulate a population trajectory with different parameter values

Lastly we want to test how the number of the genotypes fluctuate under different circumstances. Therefore we vary three parameters:

\- the starting pop size, at what time of the extinction we start

\- the number of AA that are added

\- the fitness of the hybrid

For each of those parameters, we create a vector with the different values we want to test. Next we create two data frames (similar to before) in which we collect the results of one simulation and the results of all the simulations. With the help of a triple for loop we use all the different variables that we chose for the parameter vectors. Each combination we run for multiple replications.

Using the function generate_pop we simulate the pop and after that we collect the number of genotypes at the end. Also we note at which time the pop size reached a minimum and what that minimum was, so we can see at what generation the extinction happened. Those results are added to the data frame for one simulation and then added to the total results.

At the end the first few results of the data frame are displayed.

```{r}
# set some parameters to fixed values
N_aA <- 0
r_aa <- 0.2
s_AA <- 1.1
t_max <- 200

# determine how often to run the simulation for each set of parameters
no_replicates <- 100

# set parameters to vary
N_aa_vector <- c( seq(10, 100, by=10))
N_AA_vector <- c(10, 5, 2)
s_aA_vector <- c(1, 1.1, 1.2) 


# create a data frame to save the results
data_table <- data.frame(array(NA,dim=c(0,8), dimnames=list(c(), c(paste0(c("N_aa","N_aA", "N_AA","min_gen","min_size","N_aa_str_pop","N_AA_str_pop","s_aA_fit_hybrid"),"_results")))))

# create a data frame to save the results of one loop
result_one_loop <- data.frame(array(NA,dim=c(1,8), dimnames=list(c(), c(paste0(c("N_aa","N_aA", "N_AA","min_gen","min_size","N_aa_str_pop","N_AA_str_pop","s_aA_fit_hybrid"),"_results")))))
        


##### run the simulation across all chosen parameters

# loop over starting pop size of aa
for(N_aa in N_aa_vector){
  # loop over starting pop size of AA
  for(N_AA in N_AA_vector){
    # loop over fitness of hybrid
    for(s_aA in s_aA_vector){
       
      #reset counter for no_replicates to 1
      i<-1
      repeat {
        
        # increase counter by one
        i<-i+1
        
        # run the simulation once
        one_run <- simulate_pop(N_aa = N_aa, N_aA = N_aA, N_AA = N_AA , r_aa = 0.2, s_aA = s_aA, s_AA = 1.1, t_max = 10)
     

        # collecting the number of genotypes after one simulation
        N_aa_end <- c(tail(one_run[, 1],1)) 
        N_aA_end <- c(tail(one_run[, 2],1)) 
        N_AA_end <- c(tail(one_run[, 3],1)) 

        
        # determine total population sizes
        total_size <- one_run[,1]+one_run[,2]
        
        # determine minimum population size reached during simulation
        min_size <- min(total_size)
        
        # determine (first) generation at which this population size occurred; if min pop size = 0 -> time of extinction
        min_gen <- as.numeric(which(total_size==min_size)[1])
        
        
        # enter the data into the table
        result_one_loop$N_aa_results <- N_aa_end
        result_one_loop$N_aA_results <- N_aA_end
        result_one_loop$N_AA_results <- N_AA_end
        result_one_loop$min_size_results <- min_size
        result_one_loop$min_gen_results <- min_gen
        result_one_loop$s_aA_fit_hybrid_results <- s_aA
        result_one_loop$N_aa_str_pop_results <- N_aa
        result_one_loop$N_AA_str_pop_results <- N_AA
        
        # ad the results of one simulation to the data frame with the results
        data_table <- rbind(data_table, result_one_loop)
        
        # stops loop if the simulation was run the time required
        if(i>no_replicates) break
      }       
    } 
  } 
}

# print the first few results in the data frame
print(head(data_table))

```

## Create a plot for that shitload of data

Because we have a ton of data from the for-loops, we need to summarize them to be able to process them. For that we collect all the results that came from the same combination of the parameters we varied and calculate the mean of those results.

With the means we can now create a plot to compare all the important factors.

```{r}

#open ggplot & tidyvers
library(ggplot2)
library(tidyr)

# calculate the mean of every run of the same combinations of the variables we wanted to test
mean_comb <- aggregate(data_table, list(data_table$s_aA_fit_hybrid_results, data_table$N_aa_str_pop_results, data_table$N_AA_str_pop_results), mean)




#### create a plot that compares the important aspects


# combine the results of aA and AA to compare them at the same time
long_dat <- mean_comb %>%
  pivot_longer(cols = c(N_aA_results, N_AA_results),   
               names_to = "variable",
               values_to = "value")



# create the plot
ggplot(long_dat, aes(x = N_aa_str_pop_results,
           y = value,
           colour = variable)) +
  geom_point() +
  facet_grid(
    rows = vars(factor(N_AA_str_pop_results,
                       labels = c("AA = 2", "AA = 5", "AA = 10"))),
    cols = vars(factor(s_aA_fit_hybrid_results,
                       labels = c("fitness aA =1.0", "fitness aA =1.1", "fitness aA =1.2")))
  ) +
  labs(x = "Startpopulation aa", y = "Amount of Genotype aA & AA at the end") +
  theme(strip.background = element_blank(),   # Hintergrund weg
        strip.text.x     = element_text(size = 10, face = "bold"),
        strip.text.y     = element_text(size = 10, angle = 0))

```


# Number of introduced individuals (N_AA) vs. rescue probability

In this part we made a function that calculates the rescue probability for our inbreed depressed population. A rescue is successful when at the end of a run the total population size reaches again the initial population size we started the simulation with. We then run this over a 100 replicates and plot the rescue probability against the number of introduced individuals (N_AA).

```{r}
# --- Rescue probability simulation ---

rescue_prob <- function(N_AA_intro,          # number of AA individuals introduced at t = 0
                        n_reps   = 100,      # number of replicates
                        N_aa     = 100,      # initial number of aa individuals
                        N_aA     = 0,        # initial number of aA heterozygotes
                        r_aa     = 0.2,      # decay rate (1-r_aa)
                        s_aA     = 1.10,     # selection coefficient of aA (fitness multiplier)
                        s_AA     = 1.10,     # selection coefficient of AA (fitness multiplier)
                        t_max    = 1000) {   # max generations to run each replicate

  rescue_count <- 0          # counter for successful rescues to 0

  for (i in 1:n_reps) {
    # run one population trajectory
    out <- simulate_pop(N_aa, N_aA, N_AA_intro, r_aa, s_aA, s_AA, t_max)

    # extract the final generation (last row of the returned matrix)
    last_gen <- tail(out, 1)

    # total population size at the end
    total_pop <- sum(last_gen)

    # rescue definition: final population larger than the initial one
    if (total_pop > (N_aa + N_aA + N_AA_intro)) {
      rescue_count <- rescue_count + 1
    }
  }

  # return the rescue probability
  return(rescue_count / n_reps)
}

# ------------------------------------------------------------------
# Vary the number of introduced AA individuals from 0 to 50
N_AA_values <- seq(0, 50, by = 1)

# Packing the results (calculated rescue probabilities) into a numeric vector/matrix
rescue_probs <- sapply(N_AA_values, rescue_prob, n_reps = 100)

# ------------------------------------------------------------------
# Plot
plot(N_AA_values, rescue_probs, pch = 20,
     xlab = "Number of introduced individuals (N_AA)",
     ylab = "Rescue probability",
     main = "Rescue Probability vs. Introduced Individuals")

# Add a reference line at 80 % rescue probability
target_prob <- 0.8

# Find the smallest introduction size that achieves ≥ 80 % rescue
if (any(rescue_probs >= target_prob)) {
  N_at_80 <- N_AA_values[min(which(rescue_probs >= target_prob))]

  # Draw vertical red dashed line at that introduction size
  abline(v = N_at_80, col = "red", lwd = 2, lty = 2)

  # Annotate the red line
  text(N_at_80, target_prob,
       labels = paste("> 80% at N_AA =", N_at_80),
       pos = 4, col = "red", cex = 0.8)
}
```

# Allele frequency (a) vs. introduced number of individuals (N_AA)

After knowing the rescue probability we want to investigate if the allele "a" also is rescued (Why? One possible rescue scenario is also that only AA individuals survive). So we use the same rescue probability function as before and add the calculation of the frequency of allele "a". At the end we plot the allele frequency against the number of introduced individuals. First plot is including all the extinction events, where the second plot exclude them. We exclude the extinction events in the second plot since we are interested in the allele frequency change after a certain threshold (Threshold = >80% rescue probability, as seen in previous plot at around 8-10 individuals). With out excluding them the slope of the trend line is really step and indicates that the more you introduce the better. However after reaching the threshold we are no more interested in extinction events since the rescue probability is over 80%. With that approach we can illustrate the change in allele frequency with numbers over the mentioned threshold.

```{r}
# --- Allele frequency (a) vs. introduced number of individuals (N_AA) ---

# --- PARAMETER SETUP ---

n_reps <- 100                      # Number of replicate simulations
N_aa <- 100                        # Initial number of resident aa individuals
N_AA_values <- seq(2, 20, by = 2)  # Range of introduced AA individuals (2 to 20, step 2)


# ------------------------------------------------------------------
# --- FUNCTION: rescue_prob() ---
# Similar to the previous rescue probability function, but now includes
# the calculation of the final allele frequency of "a" in each replicate.

rescue_prob <- function(N_AA_intro,           # number of AA individuals introduced at t = 0
                        n_reps,               # number of replicates
                        N_aa = 100,           # initial number of aa individuals
                        N_aA = 0,             # initial number of aA heterozygotes
                        r_aa = 0.2,           # decay rate of aa population (1 - r_aa)
                        s_aA = 1.10,          # fitness multiplier of aA
                        s_AA = 1.10,          # fitness multiplier of AA
                        t_max = 1000) {       # maximum number of generations
  
  call_freq_a <- c()   # vector to store allele frequencies for each replicate
  
  # --- SIMULATION LOOP ---
  for (i in 1:n_reps) {
    # Run one population trajectory using simulate_pop() function
    out <- simulate_pop(N_aa, N_aA, N_AA_intro, r_aa, s_aA, s_AA, t_max)
    
    # Extract the last generation (final population state)
    last_gen <- tail(out, 1)
    
    # Compute total population size at the end
    total_pop  <- sum(last_gen)
    
    # --- Determine whether the population was rescued or not ---
    # Rescue is defined as final population > initial population size
    if (total_pop > (N_aa + N_aA + N_AA_intro)) {
      # Calculate allele frequency of "a" in the final generation:
      # aa contributes 2 a-alleles, aA contributes 1 a-allele
      freq_a <- (last_gen[1]*2 + last_gen[2]) / (total_pop*2)
      call_freq_a <- rbind(call_freq_a, freq_a)
    } else {
      # If the population went extinct, record allele frequency as 0
      call_freq_a <- rbind(call_freq_a, 0)
    }
  }
  
  # Return vector of allele frequencies for all replicates
  return(call_freq_a)
}

# ------------------------------------------------------------------
# Same as before (results packing)
rescue_probs <- sapply(N_AA_values, rescue_prob, n_reps)

# ------------------------------------------------------------------
# --- DATA PREPARATION ---

# Create an array to store the relationship between N_AA and allele frequency
array_rp <- array(NA, dim = c(dim(rescue_probs)[1], 2),
                  dimnames = list(NULL, c("N_AA", "allele.freq")))

# Combine results into a data frame
for (i in seq_along(N_AA_values)) {
  val <- N_AA_values[i]
  array_rp[, 1] <- val
  temp <- rescue_probs[, i]     # i-th column = results for current N_AA value
  temp[temp == 0] <- NA          # replace 0s (extinction) with NA temporarily
  array_rp[, 2] <- temp
  array_rp <- data.frame(array_rp)
  
  if (i == 1) {
    full_array <- array_rp
  } else {
    full_array <- rbind(full_array, array_rp)
  }
}

# ------------------------------------------------------------------
# --- PLOT 1: Including extinct populations ---

# Convert NAs back to zeros (for visualization)
full_array$allele.freq[is.na(full_array$allele.freq)] <- 0

# Plot all replicates, including extinction events (freq = 0)
ggplot(full_array, aes(x = N_AA, y = allele.freq)) +
  geom_point(aes(color = allele.freq), size = 3, alpha = 0.7) +
  scale_color_viridis_c(option = "plasma", limits = c(0, 0.12)) +
  geom_smooth(
    method = "lm", se = TRUE, color = "darkred", size = 1.2, alpha = 0.3
  ) +
  scale_x_continuous(breaks = seq(2, 20, by = 2)) +
  scale_y_continuous(limits = c(0, 0.12), breaks = seq(0, 0.12, by = 0.02)) +
  labs(title = "Allele Frequencies vs. Number of Introduced Individuals",
       subtitle = paste("Start population N_aa =", N_aa),
       x = "Number of Introduced Individuals (N_AA)",
       y = "Allele Frequency (a)",
       color = "Allele Frequency") +
  theme_minimal(base_size = 12) +
  theme(plot.title.position = "plot",
        plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
        plot.subtitle = element_text(size = 12, hjust = 0.5),
        axis.title = element_text(face = "bold"),
        panel.grid.major = element_line(color = "grey90"),
        panel.grid.minor = element_blank())

# ------------------------------------------------------------------
# --- PLOT 2: Excluding extinct populations (only rescues) ---

# Filter data to include only rescued populations (allele.freq > 0)
full_array_no0 <- subset(full_array, allele.freq > 0)

# Plot only the successful rescue cases
ggplot(full_array_no0, aes(x = N_AA, y = allele.freq)) +
  geom_point(aes(color = allele.freq), size = 3, alpha = 0.7) +
  scale_color_viridis_c(option = "plasma", limits = c(0, 0.12)) +
  geom_smooth(method = "lm", se = TRUE, color = "darkred", size = 1.2, alpha = 0.3) +
  scale_x_continuous(breaks = seq(2, 20, by = 2)) +
  scale_y_continuous(limits = c(0, 0.12), breaks = seq(0, 0.12, by = 0.02)) +
  labs(title = "Allele Frequencies vs. Number of Introduced Individuals",
       subtitle = paste("Start population N_aa =", N_aa),
       x = "Number of Introduced Individuals (N_AA)",
       y = "Allele Frequency (a)",
       color = "Allele Frequency") +
  theme_minimal(base_size = 12) +
  theme(plot.title.position = "plot",
        plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
        plot.subtitle = element_text(size = 12, hjust = 0.5),
        axis.title = element_text(face = "bold"),
        panel.grid.major = element_line(color = "grey90"),
        panel.grid.minor = element_blank())
```

# Plot of allele frequency (a) vs time (varying initial number of N_aa)

After we observed the different effects of varying numbers of introduced individuals of N_AA, we now want to investigate how time plays a roll in our model. To understand the following part it is important to noticed, that we used the initial population size of N_aa as a proxy for time (i.e. the smaller the initial population size of N_aa the further time has passed, since the starting population is declining over time). Knowing that we observe the effect of time by plotting on the y-axies again the allele frequencies of "a" and now on the x-axies the initial population sizes of N_aa (as a proxy for time). 

```{r}
# --- Allele frequency (a) vs. time (varying initial number of N_aa) ---

# ------------------------------------------------------------------
# --- PARAMETER SETUP ---

n_reps <- 100                         # Number of replicate simulations
N_AA   <- 10                          # Number of AA individuals introduced at t = 0
N_aa_values <- seq(100, 10, by = -10) # Initial aa population sizes: 100, 90, 80, ..., 10


# ------------------------------------------------------------------
# --- FUNCTION: rescue_prob_aa() ---
# same function as previous, but this time with a other approach (without using rbind())

rescue_prob_aa <- function(N_aa_intro, n_reps, N_AA,
                           N_aA = 0,            # initial number of aA heterozygotes
                           r_aa = 0.2,          # decay rate of aa population (1 - r_aa)
                           s_aA = 1.10,         # fitness multiplier of aA
                           s_AA = 1.10,         # fitness multiplier of AA
                           t_max = 1000) {      # maximum number of generations
  
  # Pre-allocate a numeric vector for efficiency (faster than rbind)
  call_freq_a  <- numeric(n_reps)
  
  # --- SIMULATION LOOP ---
  for (i in seq_len(n_reps)) {
    # Run one population trajectory using simulate_pop()
    out <- simulate_pop(N_aa_intro, N_aA, N_AA, r_aa, s_aA, s_AA, t_max)
    
    # Extract the last generation
    last_gen  <- tail(out, 1)
    
    # Calculate total population size at the end
    total_pop <- sum(last_gen)
    
    # --- Determine whether the population was rescued or not ---
    # Rescue is defined as final population > initial population size
    if (total_pop > (100 + N_aA + N_AA)) {
      # Compute allele frequency of "a" in the final generation:
      # aa contributes 2 a-alleles, aA contributes 1
      call_freq_a[i] <- (last_gen[1]*2 + last_gen[2]) / (total_pop*2)
    } else {
      # If the population went extinct or failed to rescue, record NA
      call_freq_a[i] <- NA
    }
  }
  
  # Return vector of allele frequencies for all replicates
  return(call_freq_a)
}


# ------------------------------------------------------------------
# Same as previous (result = one column per N_aa value, each containing allele frequencies for all replicates)
rescue_prob_aas <- sapply(N_aa_values, rescue_prob_aa, n_reps, N_AA)


# ------------------------------------------------------------------
# --- DATA PREPARATION ---

# Convert simulation results into a data frame
full_df <- data.frame(
  N_aa          = rep(N_aa_values, each = n_reps),  # repeat each N_aa value n_reps times
  allele.freq_a = c(rescue_prob_aas)                # convert matrix into a single vector
)


# ------------------------------------------------------------------
# --- PLOTTING ---

ggplot(full_df, aes(x = N_aa, y = allele.freq_a)) +
  geom_point(aes(color = allele.freq_a), size = 2, alpha = 0.7) +    # scatter points
  scale_color_viridis_c(option = "plasma") +                         # color scale
  geom_smooth(method = "lm", se = TRUE, color = "darkred",           # linear trend line
              size = 1.2, alpha = 0.3) +
  scale_x_reverse(breaks = seq(0, 100, by = 10)) +                   # reverse x-axis (100 → 0)
  scale_y_continuous(limits = c(0, 0.12), breaks = seq(0, 0.12, by = 0.02)) +
  labs(
    title = "Allele Frequencies vs. Time of Introduction",
    subtitle = paste("Number of introduced N_AA =", N_AA),
    x = "Initial population size of N_aa",
    y = "Allele Frequency (a)",
    color = "Allele Frequency"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title.position = "plot", 
    plot.title    = element_text(face = "bold", size = 16, hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.title    = element_text(face = "bold"),
    panel.grid.major = element_line(color = "grey90"),
    panel.grid.minor = element_blank()
  )
```